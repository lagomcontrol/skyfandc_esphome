substitutions:
  name: ceilingfan
  friendly_name: Ceiling Fan

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  # Power Restore State Handling
  on_boot:
    - priority: 200  # Run after components initialized, before UART/Tuya connection
      then:
        # Read and store all restoration data
        - lambda: |-
            // Store all data: [light_on, light_brightness, light_temp, fan_on, fan_speed, fan_direction]
            
            // Light power state based on preference
            id(boot_restore_data)[0] = (id(light_power_on_state).current_option() == "Always On") ? 1 : 
                                       (id(light_power_on_state).current_option() == "Always Off") ? 0 : 
                                       id(ceilingfan_light).current_values.is_on() ? 1 : 0;
            
            // Light brightness and color temp
            id(boot_restore_data)[1] = (int)(id(ceilingfan_light).current_values.get_brightness() * 5);
            auto color_temp_mireds = id(ceilingfan_light).current_values.get_color_temperature();
            id(boot_restore_data)[2] = (color_temp_mireds > 291) ? 2 : (color_temp_mireds > 225) ? 1 : 0;
            
            // Fan power state based on preference
            id(boot_restore_data)[3] = (id(fan_power_on_state).current_option() == "Always On") ? 1 : 
                                       (id(fan_power_on_state).current_option() == "Always Off") ? 0 : 
                                       id(ceilingfan_fan).state ? 1 : 0;
            
            // Fan speed and direction
            id(boot_restore_data)[4] = (int)id(ceilingfan_fan).speed;
            id(boot_restore_data)[5] = (id(ceilingfan_fan).direction == fan::FanDirection::FORWARD) ? 0 : 1;
    
    - priority: -100  # Run late, after Tuya connection established
      then:
        # Wait for MCU to finish sending initial state
        - delay: 3s
        
        # Restore ESPHome components (handlers will send datapoints to MCU)
        - lambda: |-
            // Restore light
            auto light_call = id(ceilingfan_light).make_call();
            light_call.set_state(id(boot_restore_data)[0]);
            if (id(boot_restore_data)[0]) {
              light_call.set_brightness(id(boot_restore_data)[1] / 5.0);
              float mireds[] = {200.0, 250.0, 333.3};
              light_call.set_color_temperature(mireds[id(boot_restore_data)[2]]);
            }
            light_call.perform();
            
            // Restore fan
            auto fan_call = id(ceilingfan_fan).make_call();
            fan_call.set_state(id(boot_restore_data)[3]);
            if (id(boot_restore_data)[3]) {
              fan_call.set_speed(id(boot_restore_data)[4]);
              fan_call.set_direction(id(boot_restore_data)[5] ? fan::FanDirection::REVERSE : fan::FanDirection::FORWARD);
            }
            fan_call.perform();
            
globals:
  - id: boot_restore_data
    type: int[6]  # [light_on, light_brightness, light_temp, fan_on, fan_speed, fan_direction]
    restore_value: no
    initial_value: '{0,0,0,0,0,0}'

# Define the board for the compiler
esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
   # key: !secret api_key # uncomment when Loading into ESPHome

# Enable OTA
ota:
  - platform: esphome

# Enable Web server.
web_server:
  port: 80

# Enable WiFi and AP for captive portal
wifi:
 # ssid: !secret ssid # uncomment when Loading into ESPHome
 # password: !secret password # uncomment when Loading into ESPHome
 # domain: !secret domain # uncomment when Loading into ESPHome

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${friendly_name} ESP"

captive_portal:

uart:
  rx_pin: GPIO21
  tx_pin: GPIO20
  baud_rate: 9600 

status_led:
  pin: GPIO8

tuya:
  id: tuyamcu
  on_datapoint_update:
    # Listen for power state changes from remote
    - sensor_datapoint: 1
      datapoint_type: bool
      then:
        - lambda: |-
            id(ceilingfan_fan).make_call().set_state(x).perform();
        - component.update: light_power
        - component.update: fan_power

    # Listen for speed changes from remote
    - sensor_datapoint: 3
      datapoint_type: int
      then:
        - lambda: |-
            static const std::map<int, int> speed_map = {{1,1}, {6,2}, {2,3}, {3,4}, {4,5}, {5,6}};
            id(ceilingfan_fan).make_call().set_speed(speed_map.at(x)).perform();
        - component.update: light_power
        - component.update: fan_power

    # Listen for direction changes from remote
    - sensor_datapoint: 8
      datapoint_type: enum
      then:
        - lambda: |-
            id(ceilingfan_fan).make_call()
              .set_direction((x == 0) ? fan::FanDirection::FORWARD : fan::FanDirection::REVERSE)
              .perform();

    # Listen for light on/off from remote
    - sensor_datapoint: 15
      datapoint_type: bool
      then:
        - lambda: |-
            id(ceilingfan_light).make_call().set_state(x).perform();
        - component.update: light_power
        - component.update: fan_power

    # Listen for brightness from remote
    - sensor_datapoint: 16
      datapoint_type: int
      then:
        - lambda: |-
            id(ceilingfan_light).make_call().set_brightness(x / 5.0).perform();
        - component.update: light_power
        - component.update: fan_power

    # Listen for color temp from remote
    - sensor_datapoint: 19
      datapoint_type: enum
      then:
        - lambda: |-
            float mireds = (x == 0) ? 200.0 : (x == 1) ? 250.0 : 333.3;
            id(ceilingfan_light).make_call().set_color_temperature(mireds).perform();

light:
  - platform: cwww
    id: ceilingfan_light
    name: "${friendly_name} Light"
    cold_white: dummy_cold
    warm_white: dummy_warm
    cold_white_color_temperature: 5000 K
    warm_white_color_temperature: 3000 K
    constant_brightness: true
    disabled_by_default: true
    default_transition_length: 0s
    restore_mode: RESTORE_DEFAULT_OFF

    # Send commands to device
    on_turn_on:
      - lambda: |-
          id(tuyamcu).set_boolean_datapoint_value(15, true);

    on_turn_off:
      - lambda: |-
          id(tuyamcu).set_boolean_datapoint_value(15, false);

    on_state:
      - lambda: |-
          if (!id(ceilingfan_light).current_values.is_on()) return;
          
          // Handle brightness
          auto brightness = id(ceilingfan_light).current_values.get_brightness();
          int discrete_level = (int)(brightness * 5);
          id(tuyamcu).set_integer_datapoint_value(16, discrete_level);
          
          // Handle color temp
          auto color_temp_mireds = id(ceilingfan_light).current_values.get_color_temperature();
          int enum_value = (color_temp_mireds > 291) ? 2 : (color_temp_mireds > 225) ? 1 : 0;
          id(tuyamcu).set_enum_datapoint_value(19, enum_value);
      - component.update: fan_power
      - component.update: light_power

fan:
  - platform: template
    id: ceilingfan_fan
    name: ${friendly_name} Fan
    speed_count: 6
    has_direction: true
    has_oscillating: false
    restore_mode: RESTORE_DEFAULT_OFF

    # Send commands to device
    on_speed_set:
      - lambda: |-
          int speeds[] = {0, 1, 6, 2, 3, 4, 5};
          id(tuyamcu).set_integer_datapoint_value(3, speeds[x]);

    on_turn_on:
      - lambda: |-
          id(tuyamcu).set_boolean_datapoint_value(1, true);

    on_turn_off:
      - lambda: |-
          id(tuyamcu).set_boolean_datapoint_value(1, false);

    on_direction_set:
      - lambda: |-
          id(tuyamcu).set_enum_datapoint_value(8, (x == fan::FanDirection::FORWARD) ? 0 : 1);

    on_state:
      - component.update: fan_power
      - component.update: light_power

output:
  - platform: template
    id: dummy_warm
    type: float
    write_action:
      - lambda: 'return;'

  - platform: template
    id: dummy_cold
    type: float
    write_action:
      - lambda: 'return;'

select:
  - platform: template
    name: "${friendly_name} Fan Model"
    id: fan_model_select
    optimistic: true
    restore_value: true
    options:
      - "903"
      - "1203"
      - "1204"
      - "1303"
      - "1404"
      - "1503"
    initial_option: "1203"
    icon: "mdi:fan"
    entity_category: config

  - platform: template
    name: "${friendly_name} Light Power On State"
    id: light_power_on_state
    icon: mdi:light-recessed
    entity_category: config
    optimistic: true
    options:
      - "Restore"
      - "Always On"
      - "Always Off"
    initial_option: "Restore"
    restore_value: true
    disabled_by_default: true

  - platform: template
    name: "${friendly_name} Fan Power On State"
    id: fan_power_on_state
    icon: mdi:fan
    entity_category: config
    optimistic: true
    options:
      - "Restore"
      - "Always On"
      - "Always Off"
    initial_option: "Restore"
    restore_value: true

  - platform: tuya
    id: datapoint_mode
    tuya_id: tuyamcu
    name: ${friendly_name} Mode
    enum_datapoint: 2
    options:
      0: "Normal"
      1: "Eco"
      2: "Sleep"
    disabled_by_default: true

  - platform: tuya
    id: datapoint_timer
    tuya_id: tuyamcu
    name: ${friendly_name} Timer
    enum_datapoint: 22
    options:
      0: "Off"
      1: "1 Hour"
      2: "2 Hours"
      3: "3 Hours"
      4: "4 Hours"
      5: "5 Hours"
      6: "6 Hours"
      7: "7 Hours"
      8: "8 Hours"
      9: "9 Hours"
      10: "10 Hours"
      11: "11 Hours"
      12: "12 Hours"
    disabled_by_default: true
    
sensor:
  # WiFi signal strength
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s
    entity_category: diagnostic

  # Estimated fan power consumption based on data sheets
  - platform: template
    id: fan_power
    name: ${friendly_name} fan input power
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
          static const std::map<std::string, std::array<float, 7>> models = {
            {"903",  {0, 3, 4.8, 7, 12, 19.5, 32}},
            {"1203", {0, 3.6, 5.4, 8, 15, 22, 32.5}},
            {"1204", {0, 3.8, 5.8, 9, 17, 27, 30}},
            {"1303", {0, 3.9, 5.8, 9, 15.6, 25.2, 31.8}},
            {"1404", {0, 3.5, 5.5, 8, 15, 23, 38}},
            {"1503", {0, 3.9, 6, 9, 16, 26, 44.2}}
          };
          
          if (!id(ceilingfan_fan).state) return 0.0f;
          
          auto it = models.find(id(fan_model_select).current_option());
          return (it != models.end()) ? it->second[id(ceilingfan_fan).speed] : 0.0f;

  # Estimated led power consumption based on brightness as percentage of max wattage from datasheet
  - platform: template
    id: light_power
    name: ${friendly_name} light input power
    unit_of_measurement: "W"
    disabled_by_default: true
    device_class: "power"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      return id(ceilingfan_light).current_values.is_on() 
        ? id(ceilingfan_light).current_values.get_brightness() * 20.0f 
        : 0.0f;







