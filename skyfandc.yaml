substitutions:
  name: skyfandc01
  friendly_name: SkyFan DC01

esphome:
  name: ${name}
  friendly_name: ${friendly_name}

# Define the board for the compiler
esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino
    
# Dashboard import if you want to adopt the device on your esphome dashboard
dashboard_import:
  package_import_url: github://lagomcontrol/skyfandc_esphome/skyfandc.yaml@main

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_key

# Enable OTA
ota:
  - platform: esphome

# Enable Web server.
web_server:
  port: 80

# Enable WiFi and AP for captive portal
wifi:
  ssid: !secret ssid
  password: !secret password
  domain: !secret domain

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${friendly_name} ESP"
    password: !secret fallback_password

captive_portal:

uart:
  rx_pin: GPIO20
  tx_pin: GPIO21
  baud_rate: 9600 

status_led:
  pin: GPIO8

tuya:
  id: tuyamcu
  on_datapoint_update:
    # Listen for power state changes from remote
    - sensor_datapoint: 1
      datapoint_type: bool
      then:
        - lambda: |-
            auto call = id(patio_fan).make_call();
            if (x) {
              call.set_state(true);
            } else {
              call.set_state(false);
            }
            call.perform();
    
    # Listen for speed changes from remote and remap
    - sensor_datapoint: 3
      datapoint_type: int
      then:
        - lambda: |-
            int ha_speed;
            if (x == 1) ha_speed = 1;      // Tuya 1 (16%) -> HA Speed 1
            else if (x == 6) ha_speed = 2;  // Tuya 6 (33%) -> HA Speed 2
            else if (x == 2) ha_speed = 3;  // Tuya 2 (50%) -> HA Speed 3
            else if (x == 3) ha_speed = 4;  // Tuya 3 (67%) -> HA Speed 4
            else if (x == 4) ha_speed = 5;  // Tuya 4 (83%) -> HA Speed 5
            else ha_speed = 6;              // Tuya 5 (100%) -> HA Speed 6
            
            auto call = id(patio_fan).make_call();
            call.set_speed(ha_speed);
            call.perform();
    
    # Listen for direction changes from remote
    - sensor_datapoint: 8
      datapoint_type: enum
      then:
        - lambda: |-
            auto call = id(patio_fan).make_call();
            if (x == 0) {
              call.set_direction(fan::FanDirection::FORWARD);
            } else {
              call.set_direction(fan::FanDirection::REVERSE);
            }
            call.perform();

fan:
  - platform: template
    id: patio_fan
    name: ${friendly_name}
    speed_count: 6
    has_direction: true
    has_oscillating: false
    
    # Send commands from HA to Tuya with remapping
    on_speed_set:
      - lambda: |-
          int tuya_speed;
          if (x == 1) tuya_speed = 1;      // HA Speed 1 -> Tuya 1 (16%)
          else if (x == 2) tuya_speed = 6;  // HA Speed 2 -> Tuya 6 (33%)
          else if (x == 3) tuya_speed = 2;  // HA Speed 3 -> Tuya 2 (50%)
          else if (x == 4) tuya_speed = 3;  // HA Speed 4 -> Tuya 3 (67%)
          else if (x == 5) tuya_speed = 4;  // HA Speed 5 -> Tuya 4 (83%)
          else tuya_speed = 5;              // HA Speed 6 -> Tuya 5 (100%)
          
          id(tuyamcu).set_integer_datapoint_value(3, tuya_speed);
    
    on_turn_on:
      - lambda: 'id(tuyamcu).set_boolean_datapoint_value(1, true);'
    
    on_turn_off:
      - lambda: 'id(tuyamcu).set_boolean_datapoint_value(1, false);'
    
    on_direction_set:
      - lambda: |-
          if (x == fan::FanDirection::FORWARD) {
            id(tuyamcu).set_enum_datapoint_value(8, 0);
          } else {
            id(tuyamcu).set_enum_datapoint_value(8, 1);

          }


